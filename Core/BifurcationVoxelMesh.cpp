#include "PrecompiledHeaders.h"
#include "BifurcationVoxelMesh.h"
#include "TexGen.h"
#include "PeriodicBoundaries.h"
#include <iterator>
#include <tuple>
//#define SHINY_PROFILER TRUE


using namespace TexGen;

CBifurcationVoxelMesh::CBifurcationVoxelMesh(string Type) : CVoxelMesh(Type), a(0.0)
, b(0.0)
, c(0.0)
, firstweb(0.0)
, secondweb(0.0)
{
}

CBifurcationVoxelMesh::~CBifurcationVoxelMesh(void)
{
	//delete m_PeriodicBoundaries;
}

void CBifurcationVoxelMesh::SaveVoxelMesh(CTextile &Textile, string OutputFilename, int XVoxNum, int YVoxNum, int ZVoxNum, bool bOutputMatrix, bool bOutputYarns, int iBoundaryConditions, int iElementType)
{
	//PROFILE_SHARED_DEFINE(ProfileTest)
	//PROFILE_FUNC()

	const CDomain* pDomain = Textile.GetDomain();
	if (!pDomain)
	{
		TGERROR("Unable to create ABAQUS input file: No domain specified");
		return;
	}
	//PROFILE_SHARED_BEGIN(ProfileTest);
	m_XVoxels = XVoxNum;
	m_YVoxels = YVoxNum;
	m_ZVoxels = ZVoxNum;
	TGLOG("Calculating voxel sizes");
	if (!CalculateVoxelSizes(Textile))
	{
		TGERROR("Unable to create ABAQUS input file: Error calculating voxel sizes");
		return;
	}
	TGLOG("Replacing spaces in filename with underscore for ABAQUS compatibility");
	OutputFilename = ReplaceFilenameSpaces(OutputFilename);
	//GetYarnGridIntersections(Textile);
	CTimer timer;
	timer.start("Timing SaveToAbaqus");
	SaveToAbaqus(OutputFilename, Textile, bOutputMatrix, bOutputYarns, iBoundaryConditions, iElementType);
	timer.check("End of SaveToAbaqus");
	timer.stop();

	// PROFILE_END();
	// PROFILER_UPDATE();
	// PROFILER_OUTPUT("ProfileOutput.txt");
	//SaveToSCIRun( OutputFilename, Textile );
}

bool CBifurcationVoxelMesh::CalculateVoxelSizes(CTextile &Textile)
{
	XYZ DomSize;

	m_DomainAABB = Textile.GetDomain()->GetMesh().GetAABB();
	DomSize = m_DomainAABB.second - m_DomainAABB.first;

	m_VoxSize[0] = DomSize.x / m_XVoxels;
	m_VoxSize[1] = DomSize.y / m_YVoxels;
	m_VoxSize[2] = DomSize.z / m_ZVoxels;
	return true;
}


void CBifurcationVoxelMesh::SaveToAbaqus(string Filename, CTextile &Textile, bool bOutputMatrix, bool bOutputYarn, int iBoundaryConditions, int iElementType)
{
	//PROFILE_FUNC();
	AddExtensionIfMissing(Filename, ".inp");

	ofstream Output(Filename.c_str());

	if (!Output)
	{
		TGERROR("Unable to output voxel mesh to ABAQUS file format, could not open file: " << Filename);
		return;
	}

	TGLOG("Saving voxel mesh data to " << Filename);

	

	Output << "*Heading" << endl;
	Output << "File generated by TexGen v" << TEXGEN.GetVersion() << endl;

	Output << "************" << endl;
	Output << "*** MESH ***" << endl;
	Output << "************" << endl;
	Output << "*Node" << endl;
	//PROFILE_BEGIN(OutputNodes);
	OutputNodes(Output, Textile);

	

	//PROFILE_END();
	TGLOG("Outputting hex elements");
	//Output the voxel HEX elements
	int iNumHexElements = 0;
	if (!iElementType)
	{
		Output << "*Element, Type=C3D8R" << endl;
	}
	else
	{
		Output << "*Element, Type=C3D8" << endl;
	}
	//PROFILE_BEGIN(OutputHexElements);
	Output << "**iNumHexElements," << iNumHexElements << endl;
	iNumHexElements = OutputHexElements(Output, bOutputMatrix, bOutputYarn);
	


	//PROFILE_END();
	bool bMatrixOnly = false;
	if (bOutputMatrix && !bOutputYarn)
		bMatrixOnly = true;

	if (bOutputYarn)
	{
		TGLOG("Outputting orientations & element sets");
		//PROFILE_BEGIN(OutputOrientations);
		OutputOrientationsAndElementSets(Filename, Output);
		//PROFILE_END();
	}
	else if (bMatrixOnly)
	{
		OutputMatrixElementSet(Filename, Output, iNumHexElements, bMatrixOnly);
	}
	//PROFILE_BEGIN(OutputNodeSets);
	OutputAllNodesSet(Filename, Output);
	//PROFILE_END();
	if (iBoundaryConditions != NO_BOUNDARY_CONDITIONS)
	{
		//PROFILE_BEGIN(OutputPBCs);
		OutputPeriodicBoundaries(Output, Textile, iBoundaryConditions, bMatrixOnly);
		//PROFILE_END();
	}
	TGLOG("Finished saving to Abaqus");
}


void CBifurcationVoxelMesh::OutputNodes(ostream &Output, CTextile &Textile, bool bAbaqus)
{
	int x, y, z;
	int iNodeIndex = 1;
	vector<XYZ> CentrePoints;
	vector<POINT_INFO> RowInfo;
	XYZ Point;

	if (!bAbaqus)  // if outputting in SCIRun format need to output number of voxels
		Output << (m_XVoxels + 1)*(m_YVoxels + 1)*(m_ZVoxels + 1) << endl;
	int counter = 0;
	for (z = 0; z <= m_ZVoxels; ++z)
	{
		for (y = 0; y <= m_YVoxels; ++y)
		{
			for (x = 0; x <= m_XVoxels; ++x)
			{
				//define Point
				Point.x = m_DomainAABB.first.x + m_VoxSize[0] * x;
				Point.y = m_DomainAABB.first.y + m_VoxSize[1] * y;
				Point.z = m_DomainAABB.first.z + m_VoxSize[2] * z;

				//output corners of elements
				if (bAbaqus)
					Output << iNodeIndex << ", ";
				Output << Point << endl;

				//If Point not the end point, calculate centrepoint of element
				//Node index needs to be in order
				
				if (x < m_XVoxels && y < m_YVoxels && z < m_ZVoxels)
				{
					
					//If corner nodes within volume
					//calculate element centrepoint
					//add to CentrePoints vector
					if (Point.z < firstweb && Point.y <= a && Point.y >= b)
					{
						//find centre point of element
						Point.x += 0.5*m_VoxSize[0];
						Point.y += 0.5*m_VoxSize[1];
						Point.z += 0.5*m_VoxSize[2];
						
						CentrePoints.push_back(Point);
						//Output << "Counter is" << counter << endl;
						//counter = counter + 1;
						
					}

					else if (Point.z >= firstweb && Point.z <= secondweb && Point.y <= a && Point.y >= c)
					{
						//find centre point of element
						Point.x += 0.5*m_VoxSize[0];
						Point.y += 0.5*m_VoxSize[1];
						Point.z += 0.5*m_VoxSize[2];

						CentrePoints.push_back(Point);
						//Output << "Counter is" << counter << endl;
						//counter = counter + 1;

					} 

					else if (Point.z > secondweb && Point.y <= a && Point.y >= b)
					{
						//find centre point of element
						Point.x += 0.5*m_VoxSize[0];
						Point.y += 0.5*m_VoxSize[1];
						Point.z += 0.5*m_VoxSize[2];

						CentrePoints.push_back(Point);
						//Output << "Counter is" << counter << endl;
						//counter = counter + 1;
					}

					else
					{
						OutsidePoints.insert(OutsidePoints.end(), iNodeIndex);
						
					}

				} //index of endpoint 

				++iNodeIndex;
			} //x

				

		} //y
		RowInfo.clear();
		Textile.GetPointInformation(CentrePoints, RowInfo);
		m_ElementsInfo.insert(m_ElementsInfo.end(), RowInfo.begin(), RowInfo.end()); //size should be equal to iElementNumber at end
		CentrePoints.clear();
	
	} //z
}


bool CBifurcationVoxelMesh::IsSubset(vector<int> A, vector<int> B)
{
	//this function checks if some elements in A are in B
	vector<int> Count;
	for (vector<int>::iterator it = A.begin(); it != A.end(); ++it)
	{
		if (find(B.begin(), B.end(), *it) != B.end())
		{
			Count.push_back(*it);
		}

	}

	if (Count.size() != 0)
		return true;
	else
		return false;
}

int CBifurcationVoxelMesh::OutputHexElements(ostream &Output, bool bOutputMatrix, bool bOutputYarn, bool bAbaqus)
{
	int numx = m_XVoxels + 1;
	int numy = m_YVoxels + 1;
	int x, y, z;
	vector<POINT_INFO>::iterator itElementInfo = m_ElementsInfo.begin();
	int iElementNumber = 1;

	vector<POINT_INFO> NewElementInfo;

	if (!bAbaqus)
		Output << m_XVoxels*m_YVoxels*m_ZVoxels << endl;

	

	for (z = 0; z < m_ZVoxels; ++z)
	{
		for (y = 0; y < m_YVoxels; ++y)
		{
			for (x = 0; x < m_XVoxels; ++x)
			{
					
					if (bAbaqus)
					{	
						//Output << "vars" << x << "," << y << "," << z << endl;
						XYZ Point;
						Point.x = m_DomainAABB.first.x + m_VoxSize[0] * x;
						Point.y = m_DomainAABB.first.y + m_VoxSize[1] * y;
						Point.z = m_DomainAABB.first.z + m_VoxSize[2] * z;

						vector<int> CornerNodes;
						int f = (x + 1) + y*numx + z*numx*numy + 1;
						int g = (x + 1) + (y + 1)*numx + z*numx*numy + 1;
						int h = x + (y + 1)*numx + z*numx*numy + 1;
						int i = x + y*numx + z*numx*numy + 1;
						int j = (x + 1) + y*numx + (z + 1)*numx*numy + 1;
						int k = (x + 1) + (y + 1)*numx + (z + 1)*numx*numy + 1;
						int l = x + (y + 1)*numx + (z + 1)*numx*numy + 1;
						int m = x + y*numx + (z + 1)*numx*numy + 1;
						CornerNodes.push_back(f);
						CornerNodes.push_back(g);
						CornerNodes.push_back(h);
						CornerNodes.push_back(i);
						CornerNodes.push_back(j);
						CornerNodes.push_back(k);
						CornerNodes.push_back(l);
						CornerNodes.push_back(m);

						if (!IsSubset(CornerNodes, OutsidePoints))
						{
							Output << iElementNumber << ", ";
							Output << f << ", " << g << ", ";
							Output << h << ", " << i << ", ";
							Output << j << ", " << k << ", ";
							Output << l << ", " << m << endl;
							++iElementNumber;
							
						}			 
				
				}

			}
		
		}

	}


	if (bOutputYarn && !bOutputMatrix)
	{
		m_ElementsInfo.clear();
		m_ElementsInfo = NewElementInfo;
	}

	return (iElementNumber - 1);
	
}